#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    X_accel,        sensorAccelerometer)
#pragma config(Sensor, in2,    Y_accel,        sensorAccelerometer)
#pragma config(Sensor, in3,    Z_accel,        sensorAccelerometer)
#pragma config(Sensor, in4,    UpLightSensor,  sensorLineFollower)
#pragma config(Sensor, in5,    BtmLightSensor, sensorReflection)
#pragma config(Sensor, dgtl1,  LeftDriveEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightDriveEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  LED5,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  LED4,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, LED3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, LED2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, LED1,           sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  LauncherIME,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           UpIntake,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LeftDrive,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           LBtmL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LMidL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RMidL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RBtmL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RUpL,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LUpL,          tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           RightDrive,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          BtmIntake,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
int Program;
float wheel =0;
int boost = 0;

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
void controlFly( int speed)
{
	motor[LBtmL]= speed;
		motor[LMidL]= speed;
		motor[LUpL] = speed;
		motor[RBtmL]= speed;
		motor[RMidL] = speed;
		motor[RUpL] = speed;
}

void rst()
{
	SensorValue(LeftDriveEncoder) = 0;
	SensorValue(RightDriveEncoder)= 0;
}


void controlDrive(int speed, int timee, int staph)
{
		motor[LeftDrive] = speed;
		motor[RightDrive]= speed;
		wait1Msec(timee);
		motor[LeftDrive] = staph;
		motor[RightDrive]= staph;

	}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()//-----------------------------------------------------------------LCD CODE----------------LCD CODE---//
{
	rst();
	 // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
	//Leave this value alone
	int lcdScreenMin = 1;
	//This keeps track of which program you want to run
	int lcdScreen = 1;
	//Change this value to be the maximum number of programs you want on the robot
	int lcdScreenMax = 4;
	//Turns on the Backlight
	bLCDBacklight = true;

	//Copied from someone's sample code because the documentation for RobotC won't tell me anything useful
	//These should logically work, but I'm not 100% sure
	const short leftButton = 1;
	const short centerButton = 2;
	const short rightButton = 4;

	while (bIfiRobotDisabled == 1) { //Ensures this code will run ONLY when the robot is disabled
		if (nLCDButtons == leftButton) { //Scrolls to the left
			if (lcdScreenMin == lcdScreen) {
				lcdScreen = lcdScreenMax;
				wait1Msec(250);
			} else {
				lcdScreen --;
				wait1Msec(250);
			}
		}
		if (nLCDButtons == rightButton) { //Scrolls to the right
			if (lcdScreenMax == lcdScreen) {
				lcdScreen = lcdScreenMin;
				wait1Msec(250);
			} else {
				lcdScreen++;
				wait1Msec(250);
			}
		}
		if (lcdScreen == 1 && Program != 1) {
			displayLCDCenteredString (0, "Program"); //Name the first program here
			displayLCDCenteredString (1, "1"); //Name the first program here
			if (nLCDButtons == centerButton) {
				Program = lcdScreen; //Sets the Program to the one on-screen
				displayLCDCenteredString (0, "Autonomous Has");
				displayLCDCenteredString (1, "Been Selected!");
				wait1Msec(1500);
			}
		} else if (lcdScreen == 1 && Program == 1) {
			displayLCDCenteredString (0, "Program"); //We use brackets to mark which program we have chosen
			displayLCDCenteredString (1, "[1]"); //So that while we're scrolling, we can have one marked
		} else if (lcdScreen == 2 && Program != 2) {
			displayLCDCenteredString (0, "Program"); //Name the second program here
			displayLCDCenteredString (1, "2"); //Name the second program here
			if (nLCDButtons == centerButton) {
				Program = lcdScreen; //Sets the Program to the one on-screen
				displayLCDCenteredString (0, "Autonomous Has");
				displayLCDCenteredString (1, "Been Selected!");
				wait1Msec(1500);
			}
		} else if (lcdScreen == 2 && Program == 2) {
			displayLCDCenteredString (0, "Program"); //We use brackets to mark which program we have chosen
			displayLCDCenteredString (1, "[2]"); //So that while we're scrolling, we can have one marked
		} else if (lcdScreen == 3 && Program != 3) {
			displayLCDCenteredString (0, "Program"); //Name the third program here
			displayLCDCenteredString (1, "3"); //Name the third program here
			if (nLCDButtons == centerButton) {
				Program = lcdScreen; //Sets the Program to the one on-screen
				displayLCDCenteredString (0, "Autonomous Has");
				displayLCDCenteredString (1, "Been Selected!");
				wait1Msec(1500);
			}
		} else if (lcdScreen == 3 && Program == 3) {
			displayLCDCenteredString (0, "Program"); //We use brackets to mark which program we have chosen
			displayLCDCenteredString (1, "[3]"); //So that while we're scrolling, we can have one marked
		} else if (lcdScreen == 4 && Program != 4) {
			displayLCDCenteredString (0, "Program"); //Name the fourth program here
			displayLCDCenteredString (1, "4"); //Name the fourth program here
			if (nLCDButtons == centerButton) {
				Program = lcdScreen; //Sets the Program to the one on-screen
				displayLCDCenteredString (0, "Autonomous Has");
				displayLCDCenteredString (1, "Been Selected!");
				wait1Msec(1500);
			}
		} else if (lcdScreen == 4 && Program == 4) {
			displayLCDCenteredString (0, "Program"); //We use brackets to mark which program we have chosen
			displayLCDCenteredString (1, "[4]"); //So that while we're scrolling, we can have one marked
		}
	}

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()/////////////-------------------------------------------------auton selection
{
	if(Program == 1)
	{

		wait1Msec(200);
		controlFly(-30);
		wait1Msec(200);
		controlFly(-40);
		wait1Msec(100);
		controlFly(-50);
		wait1Msec(500);
		controlFly(-50);
		wait1Msec(2000);
		motor[UpIntake]=100;
		motor[BtmIntake]=127;
		wait1Msec(1000);
		motor[UpIntake]=60;
		motor[BtmIntake]=60;
		wait1Msec(12000);
		controlFly(-30);
		wait1Msec(500);
		controlFly(0);
		motor[UpIntake] = 0;
		motor[BtmIntake]= 0;

		//Put your second program in here
	}
	else if(Program == 2)
	{
		wait1Msec(200);
		controlFly(-30);
		wait1Msec(200);
		controlFly(-40);
		wait1Msec(100);
		controlFly(-60);
		wait1Msec(500);
		controlFly(-70);
		wait1Msec(2000);
		motor[UpIntake]=100;
		motor[BtmIntake]=127;
		wait1Msec(1000);
		motor[UpIntake]=60;
		motor[BtmIntake]=60;
		wait1Msec(12000);
		controlFly(-30);
		wait1Msec(500);
		controlFly(0);
		motor[UpIntake] = 0;
		motor[BtmIntake]= 0;
	}
	else if(Program == 3)
	{
		wait1Msec(200);
		controlFly(-30);
		wait1Msec(200);
		controlFly(-40);
		wait1Msec(100);
		controlFly(-60);
		wait1Msec(500);
		controlFly(-75);
		wait1Msec(2000);
		motor[UpIntake]=100;
		motor[BtmIntake]=127;
		wait1Msec(1000);
		motor[UpIntake]=60;
		motor[BtmIntake]=60;
		wait1Msec(12000);
		controlFly(-30);
		wait1Msec(500);
		controlFly(0);
		motor[UpIntake] = 0;
		motor[BtmIntake]= 0;
	}
	else if(Program == 4)
	{
	SensorValue[LeftDriveEncoder] =0;

  while(SensorValue[LeftDriveEncoder] < 3000)  // While less than 5 rotations on the leftEncoder...
  {
    //...Move Forward
    motor[LeftDrive] = 63;
    motor[RightDrive] = 63;
  }
  motor[LeftDrive]=0;
  motor[RightDrive]=0;
  wait1Msec(200);
		controlFly(-30);
		wait1Msec(200);
		controlFly(-40);
		wait1Msec(100);
		controlFly(-60);
		wait1Msec(1000);
		motor[UpIntake]=100;
		motor[BtmIntake]=127;
		wait1Msec(1000);
		motor[UpIntake]=100;
		motor[BtmIntake]=60;
		wait1Msec(9000);
		controlFly(0);
		motor[UpIntake]=0;
		motor[BtmIntake]=0;
	}

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task lcdstuff//------------------------------------------------------LCD SAY WHAT YOU WANT---
{
	while(true)
	{
	clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
  displayLCDPos(0,0);                   // Set the cursor to line 0, position 0 (top line, far left)
  displayNextLCDString("Hello from");   // Display "Hello from"
  displayLCDPos(1,0);                   // Set the cursor to line 1, position 0 (bottom line, far left)
  displayNextLCDString("the other side");

}
}
task secondcontroller
{
	while(true)
	{
		motor[BtmIntake] = vexRT(Ch3Xmtr2);
		motor[UpIntake]  = vexRT(Ch2Xmtr2);





	if(vexRT(Btn7RXmtr2))
	{
		wheel =0;
	}
//--------------------------------------PRESETS-------------------------------
	if(vexRT(Btn8LXmtr2))
	{
		wheel= -50;
		SensorValue(LED1)=1;
	}

	if(vexRT(Btn8DXmtr2))
	{
		wheel= -55;
		SensorValue(LED2)=1;

	}
	if(vexRT(Btn8RXmtr2))
	{
		wheel= -60;
		SensorValue(LED3)=1;
	}
	if(vexRT(Btn8UXmtr2))
	{
		wheel= -65;
		SensorValue(LED4)=1;
	}
		motor[LBtmL]= (wheel+boost);
		motor[LMidL]= (wheel+boost);
		motor[LUpL] = (wheel+boost);
		motor[RBtmL]= (wheel+boost);
		motor[RMidL] = (wheel+boost);
		motor[RUpL] = (wheel+boost);
	}
}


task driving//-------------------------------------------------------DRIVING TASK-------
{
	while(true)
	{
	motor[LeftDrive] = vexRT(Ch3);
	motor[RightDrive]= vexRT(Ch2);

	}
}
task Launching()//------------------------------------------------LAUCH AND BOOST-------
{
	while(true)
	{
	if(vexRT[Btn5U]== 1)//-------------------------BOOST-----------
	{
		boost =-3;
		SensorValue(LED5)=1;
	}
	if((vexRT[Btn5U] == 0) && (vexRT[Btn5D] == 0))
	{
		boost = 0;
		SensorValue(LED1)=0;
		SensorValue(LED2)=0;
		SensorValue(LED3)=0;
		SensorValue(LED4)=0;
		SensorValue(LED5)=0;
	}
	if(vexRT[Btn5D] == 1)
	{
		boost = 3;
	}

	if(vexRT(Btn7R))
	{
		wheel =0;
	}
//--------------------------------------PRESETS-------------------------------
	if(vexRT(Btn8L))
	{
		wheel= -50;
		SensorValue(LED1)=1;
	}

	if(vexRT(Btn8D))
	{
		wheel= -55;
		SensorValue(LED2)=1;

	}
	if(vexRT(Btn8R))
	{
		wheel= -60;
		SensorValue(LED3)=1;
	}
	if(vexRT(Btn8U))
	{
		wheel= -65;
		SensorValue(LED4)=1;
	}
		motor[LBtmL]= (wheel+boost);
		motor[LMidL]= (wheel+boost);
		motor[LUpL] = (wheel+boost);
		motor[RBtmL]= (wheel+boost);
		motor[RMidL] = (wheel+boost);
		motor[RUpL] = (wheel+boost);
	}
}




task gatherBall//-------------------------Gathers the ball----------------------------//
{
	while(true)
	{
	if (vexRT[Btn6U]==1)
	{
			motor[UpIntake] = -120;////
    	motor[BtmIntake] = 120;
	}
	else if (vexRT[Btn6D]==1)
	{
		motor[UpIntake] = 120;
		motor[BtmIntake] = 120;
	}
	else if(vexRT[Btn7D] ==1)
	{
		motor[BtmIntake] = -70;
	}
	else
	{
		motor[UpIntake] = 0;////
   	motor[BtmIntake] =0;
    }
}
}



task usercontrol()//---------------------------DOES STUFF IN TELE OP---------------------//
{

	startTask(lcdstuff);
	startTask(driving);
	startTask(Launching);
	startTask(secondcontroller);



	while(true)
	{
		startTask(gatherBall);
		wait1Msec(1);
	}
}
